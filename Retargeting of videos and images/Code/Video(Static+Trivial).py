# -*- coding: utf-8 -*-
"""Retarget(Final).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16TJisbVHDacOx-7AATRboXAeRbggWGW9
"""

!pip install opencv-python
!pip install igraph
!pip install PyMaxflow

import networkx as nx
import cv2
import numpy as np
import igraph
import maxflow
import time

def create_graph(im1):
  vids = {}
  gim1 = cv2.cvtColor(im1, cv2.COLOR_BGR2GRAY)
  id=0
  for i in range(gim1.shape[0]):
    for j in range(gim1.shape[1]):
      vids[(i,j)] = id
      id+=1
  g = maxflow.Graph[float](gim1.shape[0]*gim1.shape[1], gim1.shape[0]*gim1.shape[1]*6)
  nodes = g.add_nodes(gim1.shape[0]*gim1.shape[1])
  for i in range(gim1.shape[0]):
    for j in range(gim1.shape[1]):
      if j!=0 and j!=(gim1.shape[1]-1):
        g.add_edge(vids[(i,j)],vids[(i,j+1)],abs(gim1[i,j+1]-gim1[i,j-1]),float('inf'))
      elif j==0:
        g.add_edge(vids[(i,j)],vids[(i,j+1)],abs(gim1[i,j+1]),float('inf'))
      if i!=0 and j!=0:
        g.add_edge(vids[(i,j)],vids[(i-1,j-1)],float('inf'),0)
      if i!=(gim1.shape[0]-1) and j!=0:
        g.add_edge(vids[(i,j)],vids[(i+1,j)],abs(gim1[i+1,j] - gim1[i,j-1]),abs(gim1[i,j] - gim1[i+1,j-1]))
      elif j==0 and i!=(gim1.shape[0]-1):
        g.add_edge(vids[(i,j)],vids[(i+1,j)],abs(gim1[i+1,j]),abs(gim1[i,j]))
      if i!=(gim1.shape[0]-1) and j!=0:
        g.add_edge(vids[(i,j)],vids[(i+1,j-1)],float('inf'),0)
      if j==0:
        g.add_tedge(vids[(i,j)],float('inf'),0)
      if j==(gim1.shape[1]-1):
        g.add_tedge(vids[(i,j)],0,float('inf'))
  return g, vids

def video_reader(vid):
  video = cv2.VideoCapture(vid)
  ret, frames = video.read()
  a,b,c = frames.shape
  frames = frames.reshape((1,a,b,c))
  i=0
  while video.isOpened():
    ret, frame = video.read()
    try:
      frame = frame.reshape((1,a,b,c))
      frames = np.concatenate([frames,frame],axis=0)
    except:
      break
  video.release()
  return frames

def seq_retarget(image,n_frames, frame_count):
  f = []
  g,vids = create_graph(image)
  flow = g.maxflow()
  mask = np.ones(image.shape, dtype=bool)
  for i in range(mask.shape[0]):
    for j in range(mask.shape[1]):
      if (j+1)==mask.shape[1]:
        mask[i,j,:] = [False,False,False]
        break
      if g.get_segment(vids[(i,j)])!=g.get_segment(vids[(i,j+1)]):
        mask[i,j,:] = [False,False,False]
        break
  for i in range(frame_count):
    frame = n_frames[i,:,:,:]
    result = frame[mask].reshape((image.shape[0],image.shape[1]-1,3))
    im1 = result[:,:,:]
    f.append(im1)
  updated_image = image[mask].reshape((image.shape[0],image.shape[1]-1,3))
  return f, updated_image

def create_video(reel,n_frames,size):
  fourcc = cv2.VideoWriter_fourcc(*'mp4v')
  out = cv2.VideoWriter('project.mp4',fourcc, 15, size, True)
  for i in range(n_frames):
    out.write(reel[i])
  out.release()

def gradient_calc(image):
  x=np.zeros((image[0].shape, image[1].shape))
  y=np.zeros((image[0].shape, image[1].shape))
  im=np.zeros((image[0].shape, image[1].shape))
  for i in range(image[0].shape):
    for j in range(image[1].shape):
      if j==image[1].shape-1:
        x[i,j] = image[i,j]
      else:
        x[i,j] = abs(image[i,j]-image[i,j+1])

  for i in range(image[1].shape):
    for j in range(image[0].shape):
      if j==image[0].shape-1:
        y[j,i] = image[j,i]
      else:
        y[j,i] = abs(image[j,i]-image[j+1,i])

  for i in range(image[0].shape):
    for j in range(image[1].shape):
      im[i,j] = x[i,j]+y[i,j]

  return im

def energy_max(reel, n_frames):
  max = np.zeros((len(reel[0]),len(reel[0][0])))
  for i in range(len(reel)):
    for j in range(len(reel[0])):
      for k in range(len(reel[0][0])):
        if reel[i][j][k] > max[j][k]:
          max[j][k] = reel[i][j][k]

  return max

def retarget(im1,name):
  scount = round(0.25*im1.shape[1])
  #print(im1.shape)
  rows = im1.shape[0]
  for count in range(scount):
    #print(f'{count+1}/{scount}')
    g,vids = create_graph(im1)
    flow = g.maxflow()
    mask = np.ones(im1.shape, dtype=bool)
    for i in range(mask.shape[0]):
      for j in range(mask.shape[1]):
        if (j+1)==mask.shape[1]:
          mask[i,j,:] = [False,False,False]
          break
        if g.get_segment(vids[(i,j)])!=g.get_segment(vids[(i,j+1)]):
          mask[i,j,:] = [False,False,False]
          break
    result = im1[mask].reshape((im1.shape[0],im1.shape[1]-1,3))
    im1 = result[:,:,:]
  cv2.imwrite(name,im1)
  return im1

def static_seam(frames):
  a,b,c,d = frames.shape
  f = np.zeros((b,c,d))
  fr = []
  new_f=[]
  grad_l=[]

  for i in range(a):
    grad_l.append(cv2.cvtColor(frames[i,:,:,:], cv2.COLOR_BGR2GRAY))
  for i in range(a-1):
    n = cv2.subtract(frames[i,:,:,:],frames[i+1,:,:,:])
    fr.append(n)

  for i in range(len(fr)):
    new_f.append(cv2.cvtColor(fr[i], cv2.COLOR_BGR2GRAY))
  m1 = energy_max(new_f,len(new_f))
  m2 = energy_max(grad_l,len(grad_l))
  f_image=np.zeros((m1.shape[0],m1.shape[1]))
  for i in range(m1.shape[0]):
    for j in range(m1.shape[1]):
      f_image[i,j] = .3*m2[i,j]+.7*m1[i,j] 

  cv2.imwrite("static_seam.jpg",f_image)
  return "static_seam.jpg"

def video_retarget(frames, n_frames, name):
  alpha = cv2.imread(name)
  for i in range(round(0.25*alpha.shape[1])):
    k, x = seq_retarget(alpha,frames,n_frames)
    alpha = x
    frames = k
    frames = np.array(frames)
  print(frames.shape,len(k),k[0].shape)
  create_video(k,n_frames, (round(0.75*alpha.shape[1]),alpha.shape[0]))

def video_static_retarget(vid):
  frames = video_reader(vid)
  print(frames.shape[0])
  s = static_seam(frames)
  video_retarget(frames, frames.shape[0], s)

video_static_retarget("golf.mov")

