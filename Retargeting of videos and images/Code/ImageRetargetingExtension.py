# -*- coding: utf-8 -*-
"""Copy of Retargeting3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xF-f2j8fd5JZOL4sj9hK7y6-imHMQZuq
"""

!pip install opencv-python
!pip install igraph
!pip install PyMaxflow

import networkx as nx
import cv2
import numpy as np
import igraph
import maxflow
import time

def create_graph(im1):
  vids = {}
  gim1 = cv2.cvtColor(im1, cv2.COLOR_BGR2GRAY)
  id=0
  for i in range(gim1.shape[0]):
    for j in range(gim1.shape[1]):
      vids[(i,j)] = id
      id+=1
  g = maxflow.Graph[float](gim1.shape[0]*gim1.shape[1], gim1.shape[0]*gim1.shape[1]*6)
  nodes = g.add_nodes(gim1.shape[0]*gim1.shape[1])
  for i in range(gim1.shape[0]):
    for j in range(gim1.shape[1]):
      if j!=0 and j!=(gim1.shape[1]-1):
        g.add_edge(vids[(i,j)],vids[(i,j+1)],abs(gim1[i,j+1]-gim1[i,j-1]),float('inf'))
      elif j==0:
        g.add_edge(vids[(i,j)],vids[(i,j+1)],abs(gim1[i,j+1]),float('inf'))
      if i!=0 and j!=0:
        g.add_edge(vids[(i,j)],vids[(i-1,j-1)],float('inf'),0)
      if i!=(gim1.shape[0]-1) and j!=0:
        g.add_edge(vids[(i,j)],vids[(i+1,j)],abs(gim1[i+1,j] - gim1[i,j-1]),abs(gim1[i,j] - gim1[i+1,j-1]))
      elif j==0 and i!=(gim1.shape[0]-1):
        g.add_edge(vids[(i,j)],vids[(i+1,j)],abs(gim1[i+1,j]),abs(gim1[i,j]))
      if i!=(gim1.shape[0]-1) and j!=0:
        g.add_edge(vids[(i,j)],vids[(i+1,j-1)],float('inf'),0)
      if j==0:
        g.add_tedge(vids[(i,j)],float('inf'),0)
      if j==(gim1.shape[1]-1):
        g.add_tedge(vids[(i,j)],0,float('inf'))
  return g, vids

def retarget(im1,name):
  scount = round(0.25*im1.shape[1])
  print(im1.shape)
  rows = im1.shape[0]
  for count in range(scount):
    print(f'{count+1}/{scount}')
    g,vids = create_graph(im1)
    flow = g.maxflow()
    mask = np.ones(im1.shape, dtype=bool)
    for i in range(mask.shape[0]):
      for j in range(mask.shape[1]):
        if (j+1)==mask.shape[1]:
          mask[i,j,:] = [False,False,False]
          break
        if g.get_segment(vids[(i,j)])!=g.get_segment(vids[(i,j+1)]):
          mask[i,j,:] = [False,False,False]
          break
    result = im1[mask].reshape((im1.shape[0],im1.shape[1]-1,3))
    im1 = result[:,:,:]
  cv2.imwrite(name,im1)
  return im1

r_image = cv2.imread('butterfly2.png')
retarget(r_image,"last.jpg")

im = cv2.imread('butterfly2.png')
size = (3, 3)
shape = cv2.MORPH_RECT
kernel = cv2.getStructuringElement(shape, size)
img1 = cv2.erode(im, kernel)

retarget(img1,'re.jpg')

im = cv2.imread('re.jpg')
size = (3, 3)
shape = cv2.MORPH_RECT
kernel = cv2.getStructuringElement(shape, size)
img1 = cv2.dilate(im, kernel)
cv2.imwrite('newim.jpg',img1)

video = cv2.VideoCapture('golf.mov')
ret, frames = video.read()
print(frames.shape)
frames = frames.reshape((1,240,320,3))
i=0
while video.isOpened():
  ret, frame = video.read()
  try:
    frame = frame.reshape((1,240,320,3))
    frames = np.concatenate([frames,frame],axis=0)
  except:
    break
video.release()

frames.shape
frames[0]

f = np.zeros((240,320,3))
for i in range(82):
  n = cv2.subtract(frames[i,:,:,:],frames[i+1,:,:,:])
  f = f + n

f.shape

cv2.imwrite("check.jpg",f)

a=cv2.imread("check.jpg")
retarget(a,"result.jpg")

def seq_retarget(image,n_frames, frame_count):
  # f = np.zeros((240,320,3,1))
  f = []
  g,vids = create_graph(image)
  flow = g.maxflow()
  mask = np.ones(image.shape, dtype=bool)
  # print(mask.shape)
  for i in range(mask.shape[0]):
    for j in range(mask.shape[1]):
      if (j+1)==mask.shape[1]:
        mask[i,j,:] = [False,False,False]
        break
      if g.get_segment(vids[(i,j)])!=g.get_segment(vids[(i,j+1)]):
        mask[i,j,:] = [False,False,False]
        break
  for i in range(frame_count):
    frame = n_frames[i,:,:,:]
    # print(frame.shape)
    # print(image.shape[1])
    result = frame[mask].reshape((image.shape[0],image.shape[1]-1,3))
    im1 = result[:,:,:]
    f.append(im1)
    # f = np.concatenate([f,im1],axis = 3)
  updated_image = image[mask].reshape((image.shape[0],image.shape[1]-1,3))
  # print(updated_image.shape)
  return f, updated_image

def create_video(reel,n_frames):
  size = (480,256)
  fourcc = cv2.VideoWriter_fourcc(*'mp4v')
  out = cv2.VideoWriter('project.mp4',fourcc, 15, size, True)
  for i in range(n_frames):
    # print(reel[i])
    out.write(reel[i])
  out.release()

alpha = cv2.imread("check.jpg")
k = seq_retarget(alpha,frames,83)
print(len(k))
cv2.imwrite("test.jpg",k[56])
retarget(k[56],'re.jpg')
create_video(k,83)

alpha = cv2.imread("final.jpg")

for i in range(160):
  k, x = seq_retarget(alpha,frames,15)
  alpha = x
  frames = k
  frames = np.array(frames)

create_video(k,15)

def retarget1(im1):
  scount = round(0.25*im1.shape[1])
  print(im1.shape)
  rows = im1.shape[0]
  for count in range(scount):
    print(f'{count+1}/{scount}')
    g,vids = create_graph(im1)
    flow = g.maxflow()
    mask = np.ones(im1.shape, dtype=bool)
    for i in range(mask.shape[0]):
      for j in range(mask.shape[1]):
        if (j+1)==mask.shape[1]:
          mask[i,j,:] = [False,False,False]
          break
        if g.get_segment(vids[(i,j)])!=g.get_segment(vids[(i,j+1)]):
          mask[i,j,:] = [False,False,False]
          break
    result = im1[mask].reshape((im1.shape[0],im1.shape[1]-1,3))
    im1 = result[:,:,:]
  return im1

new_reel=[]
for i in range(83):
  new_reel.append(retarget1(frames[i,:,:,:]))

create_video(new_reel,83)

def gradient_calc(image):
  x=np.zeros((image.shape[0], image.shape[1]))
  y=np.zeros((image.shape[0], image.shape[1]))
  im=np.zeros((image.shape[0], image.shape[1]))
  for i in range(image.shape[0]):
    for j in range(image.shape[1]):
      if j==image.shape[1]-1:
        x[i,j] = image[i,j]
      else:
        x[i,j] = abs(image[i,j]-image[i,j+1])

  for i in range(image.shape[1]):
    for j in range(image.shape[0]):
      if j==image.shape[0]-1:
        y[j,i] = image[j,i]
      else:
        y[j,i] = abs(image[j,i]-image[j+1,i])

  for i in range(image.shape[0]):
    for j in range(image.shape[1]):
      im[i,j] = x[i,j]+y[i,j]

  return im

def energy_max(reel, n_frames):
 # print(reel.shape)
  max = np.zeros((len(reel[0]),len(reel[0][0])))
  for i in range(len(reel)):
    for j in range(len(reel[0])):
      for k in range(len(reel[0][0])):
        if reel[i][j][k] > max[j][k]:
          max[j][k] = reel[i][j][k]

  return max

f = np.zeros((240,320,3))
fr = []
new_f=[]
grad_l=[]

for i in range(83):
  grad_l.append(gradient_calc((cv2.cvtColor(frames[i,:,:,:], cv2.COLOR_BGR2GRAY))))
for i in range(82):
  n = cv2.subtract(frames[i,:,:,:],frames[i+1,:,:,:])
  fr.append(n)

for i in range(len(fr)):
  new_f.append(cv2.cvtColor(fr[i], cv2.COLOR_BGR2GRAY))
m1 = energy_max(new_f,len(new_f))
cv2.imwrite("temporal.jpg",m1)
m2 = energy_max(grad_l,len(grad_l))
cv2.imwrite("spatial.jpg",m2)
f_image=np.zeros((m1.shape[0],m1.shape[1]))
for i in range(m1.shape[0]):
  for j in range(m1.shape[1]):
    f_image[i,j] = .3*m2[i,j]+.7*m1[i,j] 

cv2.imwrite("spatiotemporal.jpg",f_image)

m2.shape[1]

